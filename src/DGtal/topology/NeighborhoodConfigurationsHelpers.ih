/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file NeighborhoodConfigurationsHelpers.ih
 *
 * @author Pablo Hernandez-Cerdan. Institute of Fundamental Sciences.
 * Massey University. Palmerston North, New Zealand
 *
 * @date 2016/03/25
 *
 * Implementation of header NeighborhoodConfigurationsHelpers.h
 *
 * This file is part of the DGtal library.
 */

namespace DGtal{
  namespace functions {

  template<typename TObject>
  unsigned int
  getOccupancyConfiguration(
      const TObject                 & input_obj,
      const typename TObject::Point & center,
      const std::unordered_map<
              typename TObject::Point, unsigned int > & mapPointToMask
              )
{
    using Point = typename TObject::Point;
    using Domain = typename TObject::Domain;
    using DomainConstIterator = typename Domain::ConstIterator;
    Point p1 = Point::diagonal( -1 );
    Point p2 = Point::diagonal(  1 );
    Point c = Point::diagonal( 0 );
    Domain domain( p1, p2 );
    const auto & not_found( input_obj.pointSet().end() );
    unsigned int cfg{0};
    for ( DomainConstIterator it = domain.begin(); it != domain.end(); ++it ) {
      if( *it != c  &&
          input_obj.pointSet().find( center + *it ) != not_found )
        cfg |= mapPointToMask.at(*it) ;
    }
    return cfg;
}

  template<typename TComplex>
  unsigned int
  getComplexOccupancyConfiguration(
      const          TComplex        & input_complex,
      const typename TComplex::Point & center,
      const std::unordered_map<
              typename TComplex::Point, unsigned int> & mapPointToMask)
  {
    using Point = typename TComplex::Point;
    using Space = SpaceND< Point::dimension > ;
    using Domain = HyperRectDomain< Space >;
    using DomainConstIterator = typename Domain::ConstIterator;

    Point p1 = Point::diagonal( -1 );
    Point p2 = Point::diagonal(  1 );
    Point c = Point::diagonal( 0 );
    Domain domain( p1, p2 );
    const auto & not_found( input_complex.end() );
    // const auto & not_found( input_complex.end(3) );
    unsigned int cfg{0};
    for ( DomainConstIterator it = domain.begin(); it != domain.end(); ++it ) {
      if( *it != c  &&
          input_complex.find(
                 input_complex.space().uSpel(center + *it) ) != not_found )
          // input_complex.findCell( 3,
          //     input_complex.space().uSpel(center + *it) ) != not_found )
        cfg |= mapPointToMask.at(*it) ;
    }
    return cfg;
  }

  template <typename TObject, typename TMap>
  void
  generateSimplicityTable(
      const typename TObject::DigitalTopology & dt,
      TMap & map )
  {
    typedef typename TObject::DigitalSet DigitalSet;
    typedef typename TObject::Point Point;
    typedef typename DigitalSet::Domain Domain;
    typedef typename Domain::ConstIterator DomainConstIterator;

    Point p1 = Point::diagonal( -1 );
    Point p2 = Point::diagonal(  1 );
    Point c = Point::diagonal( 0 );
    Domain domain( p1, p2 );
    DigitalSet shapeSet( domain );
    TObject shape( dt, shapeSet );
    unsigned int k = 0;
    for ( DomainConstIterator it = domain.begin(); it != domain.end(); ++it )
      if ( *it != c ) ++k;
    ASSERT( ( k < 32 )
        && "[generateSimplicityTable] number of configurations is too high." );
    unsigned int nbCfg = 1 << k;
    for ( unsigned int cfg = 0; cfg < nbCfg; ++cfg )
    {
      if ( ( cfg % 1000 ) == 0 )
      {
        trace.progressBar( (double) cfg, (double) nbCfg );
      }
      shape.pointSet().clear();
      shape.pointSet().insert( c );
      unsigned int mask = 1;
      for ( DomainConstIterator it = domain.begin(); it != domain.end(); ++it )
      {
        if ( *it != c )
        {
          if ( cfg & mask ) shape.pointSet().insert( *it );
          mask <<= 1;
        }
      }
      bool simple = shape.isSimple( c );
      map[ cfg ] = simple;
    }
  }

  } // namespace functions
} // namespace DGtal
