/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file CodedKhalimskySpaceND.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5807), University of Savoie, France
 *
 * @date 2014/06/27
 *
 * Implementation of inline methods defined in CodedKhalimskySpaceND.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include "DGtal/kernel/NumberTraits.h"
#include "DGtal/base/Bits.h"
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of static constants
///////////////////////////////////////////////////////////////////////////////

#if (!defined(WIN32))
/*template < Dimension dim, typename TInteger >
const Dimension 
DGtal::CodedKhalimskySpaceND< dim, TInteger >::dimension = dim;
*/
template < DGtal::Dimension dim, typename TInteger, typename TCode >
const DGtal::Dimension 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::DIM = dim;

template < DGtal::Dimension dim, typename TInteger, typename TCode >
const typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Sign
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::POS = true;

template < DGtal::Dimension dim, typename TInteger, typename TCode >
const typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Sign
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::NEG = false;
#endif

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// CodedCellDirectionIterator
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
DGtal::CodedCellDirectionIterator<dim, TInteger>::
CodedCellDirectionIterator( Integer dirs )
  : myDirs( dirs ), myDir( 0 )
{
  find();
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
DGtal::Dimension 
DGtal::CodedCellDirectionIterator<dim, TInteger>::
operator*() const
{
  return myDir;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
DGtal::CodedCellDirectionIterator<dim, TInteger>& 
DGtal::CodedCellDirectionIterator<dim, TInteger>::
operator++()
{
  myDirs >>= 1;
  ++myDir;
  if ( myDirs ) find();
  return *this;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool
DGtal::CodedCellDirectionIterator<dim, TInteger>::
operator!=( const Integer ) const
{
  return myDir < dim;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
bool
DGtal::CodedCellDirectionIterator<dim, TInteger>::
end() const
{
  return myDir >= dim;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
bool
DGtal::CodedCellDirectionIterator<dim, TInteger>::
operator!=( const CodedCellDirectionIterator & other ) const
{
  return myDir != other.myDir;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
bool
DGtal::CodedCellDirectionIterator<dim, TInteger>::
operator==( const CodedCellDirectionIterator & other ) const
{
  return myDir == other.myDir;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
void
DGtal::CodedCellDirectionIterator<dim, TInteger>::
find()
{
  while ( ( myDirs & 1 ) == 0 )
    {
      myDirs >>= 1;
      ++myDir;
    }
}


///////////////////////////////////////////////////////////////////////////////
// CodedKhalimskySpaceND
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
~CodedKhalimskySpaceND()
{
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
CodedKhalimskySpaceND()
{
  init( Point::zero, Point::zero, true );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
init( const Point & lower,
      const Point & upper,
      bool closed )
{
  if ( ! lower.isLower( upper ) ) return false;
  myIsClosed         = closed;
  myLower            = lower;
  myUpper            = upper;
  mySizes            = Point::diagonal(1) + myUpper - myLower;
  myLowerCell        = 2 * myLower;
  myUpperCell        = 2 * ( myUpper + Point::diagonal(1) );
  myLowerValidCell   = myIsClosed ? myLowerCell : Point::diagonal(1) + myLowerCell;
  myUpperValidCell   = myIsClosed ? myUpperCell : Point::diagonal(1) + myUpperCell;
  const Code zero    = 0;
  const Code one     = 1;
  Dimension shift    = 0;
  myNbBits           = 0;
  myNbCellTypes      = 1 << dimension;
  myCodedAllCoordMax = 0;
  myNbSpels          = one;
  myBFCoords         = BitFields( dimension );
  myCodedCoordMaxs   = Codes( dimension, zero );
  myCodedCoordIncrs  = Codes( dimension, zero );
  // Computing masks for coordinates.
  for ( Dimension i = 0; i < dimension; i++ )
    {
      // nb_bits : nb of bits used to define coordinate.
      myNbSpels               *= mySizes[ i ];
      Size size_axis           = myIsClosed ? mySizes[ i ] : mySizes[ i ] - 1;
      Dimension nb_bits        = 1 + Bits::mostSignificantBit( size_axis );
      myBFCoords[ i ]          = BitField( ( ( one << nb_bits ) - one ) << shift, 
                                           shift, nb_bits );
      myCodedCoordMaxs[ i ]    = ( mySizes[ i ] - one ) << shift;
      myCodedAllCoordMax      += myCodedCoordMaxs[ i ];
      myCodedCoordIncrs[ i ]   = one << shift;
      myNbBits                += nb_bits;
      shift                   += nb_bits;
      trace.info() << "size[" << i << "]=" << size_axis << " bits=" << nb_bits << std::endl;
    }
  // Storing shift for directions.
  Dimension dirs_shift = shift;
  // Computing mask for all coords
  myBFAllCoords = BitField( ( one << shift ) - one, 0, shift );
  // Computing mask for directions 
  myBFAllDirs   = BitField( ( ( one << dimension ) - one ) << dirs_shift, 
                            dirs_shift, dimension );
  myBFDirs      = BitFields( dimension );
  for ( Dimension i = 0; i < dimension; ++i )
    {
      myBFDirs[ i ]  = BitField( one << shift, shift, 1 );
      myNbBits      += 1;
      shift         += 1;
    }
  // Computing mask for sign of SCell
  myBFSign           = BitField( one << shift, shift, 1 );
  /// Field to reach all directions and the sign in a coded SCell (no meaning for Cell).
  myBFAllDirsAndSign = BitField( ( ( one << (dimension+1) ) - one ) << dirs_shift, 
                                 dirs_shift, dimension+1 );
  myNbBits          += 1;
  shift             += 1;

  // Checks that Code type has enough bits to represents all cells
  // within the given space bounds.
  if ( myNbBits > NumberTraits<Code>::digits() )
    {
      trace.error() << "[CodedKhalimskySpaceND::init] Unable to create space. Requires "
                    << myNbBits << " while Code type offers only "
                    << NumberTraits<Code>::digits() << " bits." << std::endl;
      return false;
    }

  // Computing incidence LUT.
  computeIncidenceLUT();

  // Computing permutation LUT.
  computePermutationLUT();

  // Computing coordinates for each cell type.
  myCodedCellTypeIncrs = Codes( myNbCellTypes );
  for ( Dimension i = 0; i < myNbCellTypes; ++i )
    {
      Code uid = 0;
      for ( Dimension b = 0; b < dimension; ++b )
	if ( i & ( 1 << b ) ) 
          uid |= myCodedCoordIncrs[ b ];
      myCodedCellTypeIncrs[ i ] = uid;
    }

  // Computing coordinates of vertices for each cell type.
  myCodedCoordsVtx = Codes( myNbCellTypes * myNbCellTypes );
  for ( Dimension i = 0; i < myNbCellTypes; ++i )
    {
      Dimension nb = 0;
      for ( Dimension j = 0; j < myNbCellTypes; ++j )
	{
	  if ( myLowIncident[ ( i << dimension ) + j ] )
	    {
              ASSERT( i >= j );
              myCodedCoordsVtx[ ( i << dimension ) + nb ] 
		= myCodedCellTypeIncrs[ i - j ];
	      nb++;
	    }
	}
      std::sort( myCodedCoordsVtx.begin() + ( i << dimension ),
                 myCodedCoordsVtx.begin() + ( ( i << dimension ) + nb ) );
    }

  // Compute direct orientation LUT.
  computeDirectOrientationLUT();

  // Compute binomials.
  computeBinomials();

  // Compute tangent and orthogonal directions LUT.
  myOrthDir       = std::vector<Dimension>( myNbCellTypes );
  myTgtDir        = std::vector<Dimension>( myNbCellTypes );
  for ( Dimension i = 0; i < myNbCellTypes; ++i )
    {
      Dimension n    = Bits::nbSetBits( i );
      myOrthDir[ i ] = dimension;
      myTgtDir[ i ]  = dimension;
      if ( n == dimension - 1 ) myOrthDir[ i ] = Bits::leastSignificantBit( ~ i );
      else if ( n == 1 )        myTgtDir[ i ]  = Bits::leastSignificantBit(   i );
    }
  myLowerCellCode = uCell( myLowerValidCell );
  myUpperCellCode = uCell( myUpperValidCell );
  return true;
}

//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
computeDirectOrientationLUT()
{
  // Fills direct orientations LUT.
  mySDirectOrientation = std::vector<bool>( ( 1 << (dimension+1) ) * dimension );
  for ( Code i = 0; i < myNbCellTypes; ++i )
    for ( Dimension b = 0; b < dimension; ++b )
      {
        Dimension offset   = ( b << ( dimension + 1 ) ) + i;
        Code inc_cell      = mySIncident2[ offset ];
        Sign inc_cell_sign = inc_cell & myNbCellTypes;
        mySDirectOrientation[ offset ]                 = inc_cell_sign;
        mySDirectOrientation[ offset + myNbCellTypes ] = ! inc_cell_sign;
        trace.info() << "Cell[" << i << ",-].inc2(" << b << ") = " << inc_cell<< std::endl;
        trace.info() << "Cell[" << i << ",-].sDirect(" << b << ") = " 
                     << mySDirectOrientation[ offset ]  << std::endl;
        trace.info() << "Cell[" << i << ",+].sDirect(" << b << ") = " 
                     << mySDirectOrientation[ offset + myNbCellTypes ] << std::endl;
      }
}

//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
computeBinomials()
{
  myBinomials = std::vector<Integer>( dimension + 1, 0 );
  myBinomials[ 0 ] = 1;
  for ( Dimension i = 1; i <= dimension; ++i )  
    for ( Dimension j = 1; j <= dimension; ++j )  
      myBinomials[ j ] += myBinomials[ j - 1 ];
}

//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
computeIncidenceLUT()
{
  Dimension k; // it is the directions of the first cell.
  Dimension l; // it is the directions of the second cell.
  Dimension b; // it is the current direction.
  Dimension nb_celltypes = 1 << dimension; // the number of possible directions.
  myLowIncident          = std::vector<bool>( 1 << (2*dimension) );
  myUpIncident           = std::vector<bool>( 1 << (2*dimension) );
  // We compute the low-incidence LUT (meaning [l] in the low-incidence of [k])
  // We compute the up-incidence LUT (meaning [l] in the up-incidence of [k])
  // Two nested loops to examine each case.
  for ( k = 0; k < nb_celltypes; ++k ) // loop on all directions
    for ( l = 0; l < nb_celltypes; ++l ) // loop on all directions
      {
	bool low_incident = true;
	bool up_incident = true;
	for ( b = 1; b < nb_celltypes; b <<= 1 ) // loop on all bits
	  {
	    if ( ( k & b ) && ( ! ( l & b ) ) )
	      up_incident = false;
	    else if ( ( ! ( k & b ) ) && ( l & b ) )
	      low_incident = false;
	    // proceed to next bit otherwise.
	  }
	Dimension offset        = ( k << dimension ) + l;
	myLowIncident[ offset ] = low_incident;
	myUpIncident[ offset ]  = up_incident;
      }
}

//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
computePermutationLUT()
{
  Code one               = 1;
  Code set_sign          = myNbCellTypes; // strongest bi
  // Initialize permutation LUT.
  myPermutation          = std::vector<bool>( myNbCellTypes * dimension );
  // Set incidence matrix to 0.
  mySLowIncidenceMatrix  = std::vector<DGtal::int8_t>( 4 * myNbCellTypes * myNbCellTypes, 0 );
  // Set size of topology incident vectors.
  mySIncident1           = Codes( 2 * myNbCellTypes * dimension );
  mySIncident2           = Codes( 2 * myNbCellTypes * dimension );
  // Fills incidence LUTs and matrix.
  for ( Code i = 0; i < myNbCellTypes; ++i )
    {
      // First incident are low, second incident are up
      bool pos_cell = POS == false; // neg_cell have their sign = 0, pos_cell = 1
      bool up = false;
      bool sign = up ? pos_cell : ! pos_cell;
      for ( DGtal::Dimension b = 0; b < dimension; ++b )
        {
          if ( i ^ ( one << b ) ) // cell is open along coordinate b.
            sign = ! sign;
	  Dimension unsigned_offset = ( b << dimension ) + i;
	  myPermutation[ unsigned_offset ] = sign;
	  Dimension signed_offset   = ( b << (dimension+1) ) + i; // + ( i << 1 );
          Dimension j               = ( i ^ ( one << b ) );
          mySIncident1[ signed_offset ] = j + ( sign ? set_sign : 0 );
          mySIncident2[ signed_offset ] = j + ( sign ? 0 : set_sign );
          mySIncident1[ signed_offset + myNbCellTypes ] = j + ( sign ? 0 : set_sign );
          mySIncident2[ signed_offset + myNbCellTypes ] = j + ( sign ? set_sign : 0 );
	  if ( i & ( one << b ) )
	    {
              mySLowIncidenceMatrix[ (i << (dimension+1)) + j ]
 		= ( sign ? 1 : -1 );
              mySLowIncidenceMatrix[ (i << (dimension+1)) + j + set_sign ]
 		= ( sign ? -1 : 1 );
              mySLowIncidenceMatrix[ ((i+set_sign) << (dimension+1)) + j ]
 		= ( sign ? -1 : 1 );
              mySLowIncidenceMatrix[ ((i+set_sign) << (dimension+1)) + j + set_sign ]
 		= ( sign ? 1 : -1 );
	    }
	}
    }
}

//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Size
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
size( DGtal::Dimension k ) const
{
  ASSERT( k < dimension );
  return mySizes[ k ];
}

//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
TInteger 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
min( DGtal::Dimension k ) const
{
  return myLower[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
TInteger 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
max( DGtal::Dimension k ) const
{
  return myUpper[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
const typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Point &
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
lowerBound() const
{
  return myLower;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
const typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Point &
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
upperBound() const
{
  return myUpper;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
const typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell &
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
lowerCell() const
{
  return myLowerCellCode;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
const typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell &
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
upperCell() const
{
  return myUpperCellCode;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
isSpaceClosed() const
{
  return myIsClosed;
}

//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uCell( Point kp ) const
{
  ASSERT( myLowerValidCell.inf( kp ) == myLowerValidCell ); 
  ASSERT( myUpperValidCell.sup( kp ) == myUpperValidCell ); 
  kp -= myLowerCell;
  typename Point::ConstIterator it  = kp.begin();
  Cell c = NumberTraits<Code>::ZERO;
  for ( Dimension i = 0; i < dimension; ++i, ++it )
    {
      c = myBFCoords[ i ].codeWithValue( c, *it >> 1 );
      if ( (*it) & 1 ) c |= myBFDirs[ i ].mask;
    }
  return c;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uCell( Point p, Cell c ) const
{
  ASSERT( myLower.inf( p ) == myLower );
  ASSERT( myUpper.sup( p ) == myUpper );
  p -= myLower;
  typename Point::ConstIterator it  = p.begin();
  for ( Dimension i = 0; i < dimension; ++i, ++it )
    {
      c = myBFCoords[ i ].codeWithValue( c, *it );
    }
  return c;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sCell( Point kp, Sign sign ) const
{
  return sign == POS ? ( uCell( kp ) | myBFSign.mask ) : uCell( kp );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sCell( Point p, SCell c ) const
{
  return uCell( p, c ); // the sign is already in c.
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uSpel( const Point& p ) const
{
  // The directions bitfield mask corresponds to a cell open in all
  // directions, hence a spel.
  return uCell( p, myBFAllDirs.mask ); 
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sSpel( const Point& p, Sign sign ) const
{
  // The directions bitfield mask corresponds to a cell open in all
  // directions, hence a spel.
  return sign == POS
    ? uCell( p, myBFAllDirsAndSign.mask )
    : uCell( p, myBFAllDirs.mask );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uPointel( const Point& p ) const
{
  // A pointel has all its directions closed, hence 0.
  return uCell( p, NumberTraits<Code>::ZERO );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sPointel( const Point& p, Sign sign ) const
{
  // A pointel has all its directions closed, hence 0.
  return sign == POS
    ? uCell( p, myBFSign.mask )
    : uCell( p, NumberTraits<Code>::ZERO );
}
//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Integer
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uKCoord( Cell c, DGtal::Dimension k ) const
{
  ASSERT( k < DIM );
  return myLowerCell[ k ] + ( myBFCoords[ k ].valueOfCode( c ) << 1 )
    + ( myBFDirs.bitCheck( c, k ) ? 1 : 0 );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Integer 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uCoord( Cell c, DGtal::Dimension k ) const
{
  ASSERT( k < DIM );
  return myLower[ k ] + myBFCoords[ k ].valueOfCode( c );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Point
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uKCoords( Cell c ) const
{
  Point kp = myLowerCell;
  for ( Dimension k; k < dimension; ++k )
    kp[ k ] += ( myBFCoords[ k ].valueOfCode( c ) << 1 )
      + ( myBFDirs.bitCheck( c, k ) ? 1 : 0 );
  return kp;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Point
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uCoords( Cell c ) const
{
  Point kp = myLower;
  for ( Dimension k; k < dimension; ++k )
    kp[ k ] += myBFCoords[ k ].valueOfCode( c );
  return kp;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Integer
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sKCoord( SCell c, DGtal::Dimension k ) const
{
  ASSERT( k < DIM );
  return myLowerCell[ k ] + ( myBFCoords[ k ].valueOfCode( c ) << 1 )
    + ( myBFDirs.bitCheck( c, k ) ? 1 : 0 );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Integer 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sCoord( SCell c, DGtal::Dimension k ) const
{
  ASSERT( k < DIM );
  return myLower[ k ] + myBFCoords[ k ].valueOfCode( c );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Point
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sKCoords( SCell c ) const
{
  Point kp = myLowerCell;
  for ( Dimension k; k < dimension; ++k )
    kp[ k ] += ( myBFCoords[ k ].valueOfCode( c ) << 1 )
      + ( myBFDirs.bitCheck( c, k ) ? 1 : 0 );
  return kp;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Point
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sCoords( SCell c ) const
{
  Point kp = myLower;
  for ( Dimension k; k < dimension; ++k )
    kp[ k ] += myBFCoords[ k ].valueOfCode( c );
  return kp;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Sign
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sSign( SCell c ) const
{
  return ( myBFSign.mask & c ) ? POS : NEG;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCell 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
signs( Cell p, Sign s ) const
{
  return s == POS ? ( p | myBFSign.mask ) : p;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
unsigns( SCell p ) const
{
  return myBFSign.unselect( p );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCell 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sOpp( SCell p ) const
{
  return myBFSign.flip( p );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uSetKCoord( Cell & c, DGtal::Dimension k, Integer i ) const
{
  ASSERT( k < dimension );
  ASSERT( myLowerValidCell[ k ] <= i );
  ASSERT( i <= myUpperValidCell[ k ] );
  myBFCoords[ k ].setValue( c, ( i - myLowerCell[ k ] ) >> 1 );
  myBFDirs[ k ].setValue( c, i & 1 );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sSetKCoord( SCell & c, DGtal::Dimension k, Integer i ) const
{
  ASSERT( k < dimension );
  ASSERT( myLowerValidCell[ k ] <= i );
  ASSERT( i <= myUpperValidCell[ k ] );
  myBFCoords[ k ].setValue( c, ( i - myLowerCell[ k ] ) >> 1 );
  myBFDirs[ k ].setValue( c, i & 1 );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uSetCoord( Cell & c, DGtal::Dimension k, Integer i ) const
{
  ASSERT( k < dimension );
  ASSERT( myLower[ k ] <= i );
  ASSERT( i <= myUpper[ k ] );
  myBFCoords[ k ].setValue( c, i - myLower[ k ] );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sSetCoord( SCell & c, DGtal::Dimension k, Integer i ) const
{
  ASSERT( k < dimension );
  ASSERT( myLower[ k ] <= i );
  ASSERT( i <= myUpper[ k ] );
  myBFCoords[ k ].setValue( c, i - myLower[ k ] );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uSetKCoords( Cell & c, const Point & kp ) const
{
  ASSERT( myLowerValidCell.inf( kp ) == myLowerValidCell );
  ASSERT( myUpperValidCell.sup( kp ) == myUpperValidCell );
  for ( Dimension i = 0; i < dimension; ++i )
    {
      Integer v = kp[ i ];
      myBFCoords[ i ].setValue( c, ( v - myLowerCell[ i ] ) >> 1 );
      myBFDirs[ i ].setValue( c, v & 1 );
    }
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sSetKCoords( SCell & c, const Point & kp ) const
{
  ASSERT( myLowerValidCell.inf( kp ) == myLowerValidCell );
  ASSERT( myUpperValidCell.sup( kp ) == myUpperValidCell );
  for ( Dimension i = 0; i < dimension; ++i )
    {
      Integer v = kp[ i ];
      myBFCoords[ i ].setValue( c, ( v - myLowerCell[ i ] ) >> 1 );
      myBFDirs[ i ].setValue( c, v & 1 );
    }
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uSetCoords( Cell & c, const Point & p ) const
{
  ASSERT( myLower.inf( p ) == myLower );
  ASSERT( myUpper.sup( p ) == myUpper );
  for ( DGtal::Dimension k = 0; k < dimension; ++k )
    {
      myBFCoords[ k ].setValue( c, p[ k ] - myLower[ k ] );
    }
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sSetCoords( SCell & c, const Point & p ) const
{
  ASSERT( myLower.inf( p ) == myLower );
  ASSERT( myUpper.sup( p ) == myUpper );
  for ( DGtal::Dimension k = 0; k < dimension; ++k )
    {
      myBFCoords[ k ].setValue( c, p[ k ] - myLower[ k ] );
    }
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sSetSign( SCell & c, Sign s ) const
{
  if ( s == POS ) c |= myBFSign.mask;
  else            c &= myBFSign.inv_mask;
}
//-----------------------------------------------------------------------------
// ------------------------- Cell topology services -----------------------
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
TInteger
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uTopology( Cell p ) const
{
  return myBFAllDirs.value( p );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
TInteger
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sTopology( SCell p ) const
{
  return myBFAllDirs.value( p );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
DGtal::Dimension
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uDim( Cell p ) const
{
  return Bits::nbSetBits( (Size) myBFAllDirs.value( p ) );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
DGtal::Dimension
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sDim( SCell p ) const
{
  return Bits::nbSetBits( (Size) myBFAllDirs.value( p ) );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uIsSurfel( Cell b ) const
{
  return uDim( b ) == ( dimension - 1 );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sIsSurfel( SCell b ) const
{
 return sDim( b ) == ( dimension - 1 );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uIsOpen( Cell p, DGtal::Dimension k ) const
{
  return p & myBFAllDirs[ k ].mask;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sIsOpen( SCell p, DGtal::Dimension k ) const
{
  return p & myBFAllDirs[ k ].mask;
}

//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::DirIterator
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uDirs( Cell p ) const
{
  return DirIterator( myBFAllDirs.value( p ) );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::DirIterator
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sDirs( SCell p ) const
{
  return DirIterator( myBFAllDirs.value( p ) );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::DirIterator
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uOrthDirs( Cell p ) const
{
  return DirIterator( ( myNbCellTypes - 1 ) ^ myBFAllDirs.value( p ) );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::DirIterator
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sOrthDirs( SCell p ) const
{
  return DirIterator( ( myNbCellTypes - 1 ) ^ myBFAllDirs.value( p ) );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
DGtal::Dimension 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uOrthDir( Cell s ) const
{
  Dimension k = myOrthDir[ myBFDirs.value( s ) ];
  ASSERT( k < dimension );
  return k;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
DGtal::Dimension 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sOrthDir( SCell s ) const
{
  Dimension k = myOrthDir[ myBFDirs.value( s ) ];
  ASSERT( k < dimension );
  return k;
}

//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uFirst( Cell p ) const
{
  return myBFDirs.select( p );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uLast( Cell p ) const
{
  return myBFAllDirs.select( p ) | myBFAllCoords.select( myUpperCellCode );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uGetIncr( Cell p, DGtal::Dimension k ) const
{
  ASSERT( ! uIsMax( p, k ) );
  return p + myCodedCoordIncrs[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uIsMax( Cell p, DGtal::Dimension k ) const
{
  return myBFDirs[ k ].value( p ) == myBFCoords[ k ].select( myUpperCellCode );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uIsInside( Cell p, DGtal::Dimension k ) const
{
  Integer x = myBFDirs[ k ].value( p ); // cannot be negative
  return x <= myBFCoords[ k ].select( myUpperCellCode );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uGetMax( Cell p, DGtal::Dimension k ) const
{
  return uProjection( p, myUpperCellCode, k );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uGetDecr( Cell p, DGtal::Dimension k ) const
{
  ASSERT( ! uIsMin( p, k ) );
  return p - myCodedCoordIncrs[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uIsMin( Cell p, DGtal::Dimension k ) const
{
  return myBFDirs[ k ].value( p ) == 0;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uGetMin( Cell p, DGtal::Dimension k ) const
{
  return uProjection( p, myLowerCellCode, k );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uGetAdd( Cell p, DGtal::Dimension k, Integer x ) const
{
  ASSERT( ( uCoord( p, k ) + x ) <= myUpper[ k ] );
  return p + myBFCoords[ k ].codeValue( x );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uGetSub( Cell p, DGtal::Dimension k, Integer x ) const
{
  ASSERT( ( uCoord( p, k ) - x ) >= myLower[ k ] );
  return p - myBFCoords[ k ].codeValue( x );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
TInteger
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uDistanceToMax( Cell p, DGtal::Dimension k ) const
{
  return myUpper[ k ] - myBFCoords[ k ].value( p );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
TInteger
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uDistanceToMin( Cell p, DGtal::Dimension k ) const
{
  return myBFCoords[ k ].value( p ) - myLower[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uTranslation( Cell p, const Vector & vec ) const
{
  ASSERT( myLower.inf( uCoords( p ) + vec ) == myLower );
  ASSERT( myUpper.sup( uCoords( p ) + vec ) == myUpper );
  for ( DGtal::Dimension k = 0; k < dimension; ++k )
    {
      Integer v = vec[ k ];
      if ( v >= 0 ) p += myBFCoords[ k ].codeValue( v );
      else          p -= myBFCoords[ k ].codeValue( -v );
    }
  return p;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uProjection( Cell p, Cell bound, DGtal::Dimension k ) const
{
  return myBFCoords[ k ].codeWithCodedValue( p, myBFCoords[ k ].select( bound ) );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uProject( Cell & p, Cell bound, DGtal::Dimension k ) const
{
  myBFCoords[ k ].changeCode( p, myBFCoords[ k ].select( bound ) );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uNext( Cell & p, Cell lower, Cell upper ) const
{
  DGtal::Dimension k = NumberTraits<Dimension>::ZERO;
  if ( myBFCoords[ 0 ].select( p ) == myBFCoords[ 0 ].select( upper ) )
    {
      if ( myBFAllCoords.select( p ) == myBFAllCoords.select( upper ) ) return false;
      uProject( p, lower, 0 );
      for ( k = 1; k < dimension; ++k )
        {
          if ( myBFCoords[ k ].select( p ) == myBFCoords[ k ].select( upper ) )
            uProject( p, lower, k );
          else
            {
              p += myCodedCoordIncrs[ k ];
              break;
            }
        }
      return true;
    }
  p += myCodedCoordIncrs[ 0 ];
  return true;
}

//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sFirst( SCell p ) const
{
  return myBFDirs.select( p );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sLast( SCell p ) const
{
  return myBFAllDirs.select( p ) | myBFAllCoords.select( myUpperCellCode );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sGetIncr( SCell p, DGtal::Dimension k ) const
{
  ASSERT( ! uIsMax( p, k ) );
  return p + myCodedCoordIncrs[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sIsMax( SCell p, DGtal::Dimension k ) const
{
  return myBFDirs[ k ].value( p ) == myBFCoords[ k ].select( myUpperCellCode );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sIsInside( SCell p, DGtal::Dimension k ) const
{
  Integer x = myBFDirs[ k ].value( p ); // cannot be negative
  return x <= myBFCoords[ k ].select( myUpperCellCode );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sGetMax( SCell p, DGtal::Dimension k ) const
{
  return uProjection( p, myUpperCellCode, k );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sGetDecr( SCell p, DGtal::Dimension k ) const
{
  ASSERT( ! uIsMin( p, k ) );
  return p - myCodedCoordIncrs[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sIsMin( SCell p, DGtal::Dimension k ) const
{
  return myBFDirs[ k ].value( p ) == 0;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sGetMin( SCell p, DGtal::Dimension k ) const
{
  return uProjection( p, myLowerCellCode, k );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sGetAdd( SCell p, DGtal::Dimension k, Integer x ) const
{
  ASSERT( ( uCoord( p, k ) + x ) <= myUpper[ k ] );
  return p + myBFCoords[ k ].codeValue( x );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sGetSub( SCell p, DGtal::Dimension k, Integer x ) const
{
  ASSERT( ( uCoord( p, k ) - x ) >= myLower[ k ] );
  return p - myBFCoords[ k ].codeValue( x );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
TInteger
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sDistanceToMax( SCell p, DGtal::Dimension k ) const
{
  return myUpper[ k ] - myBFCoords[ k ].value( p );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
TInteger
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sDistanceToMin( SCell p, DGtal::Dimension k ) const
{
  return myBFCoords[ k ].value( p ) - myLower[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sTranslation( SCell p, const Vector & vec ) const
{
  ASSERT( myLower.inf( uCoords( p ) + vec ) == myLower );
  ASSERT( myUpper.sup( uCoords( p ) + vec ) == myUpper );
  for ( DGtal::Dimension k = 0; k < dimension; ++k )
    {
      Integer v = vec[ k ];
      if ( v >= 0 ) p += myBFCoords[ k ].codeValue( v );
      else          p -= myBFCoords[ k ].codeValue( -v );
    }
  return p;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sProjection( SCell p, Cell bound, DGtal::Dimension k ) const
{
  return myBFCoords[ k ].codeWithCodedValue( p, myBFCoords[ k ].select( bound ) );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sProject( SCell & p, Cell bound, DGtal::Dimension k ) const
{
  myBFCoords[ k ].changeCode( p, myBFCoords[ k ].select( bound ) );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sNext( SCell & p, Cell lower, Cell upper ) const
{
  DGtal::Dimension k = NumberTraits<Dimension>::ZERO;
  if ( myBFCoords[ 0 ].select( p ) == myBFCoords[ 0 ].select( upper ) )
    {
      if ( myBFAllCoords.select( p ) == myBFAllCoords.select( upper ) ) return false;
      uProject( p, lower, 0 );
      for ( k = 1; k < dimension; ++k )
        {
          if ( myBFCoords[ k ].select( p ) == myBFCoords[ k ].select( upper ) )
            uProject( p, lower, k );
          else
            {
              p += myCodedCoordIncrs[ k ];
              break;
            }
        }
      return true;
    }
  p += myCodedCoordIncrs[ 0 ];
  return true;
}


//-----------------------------------------------------------------------------
// ----------------------- Neighborhood services --------------------------
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cells 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uNeighborhood( const Cell & c ) const
{
  Cells N;
  N.push_back( c );
  for ( DGtal::Dimension k = 0; k < dimension; ++k )
    {
      if ( ! uIsMin( c, k ) )
  N.push_back( uGetDecr( c, k ) );
      if ( ! uIsMax( c, k ) )
  N.push_back( uGetIncr( c, k ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCells 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sNeighborhood( const SCell & c ) const
{
  SCells N;
  N.push_back( c );
  for ( DGtal::Dimension k = 0; k < dimension; ++k )
    {
      if ( ! sIsMin( c, k ) )
  N.push_back( sGetDecr( c, k ) );
      if ( ! sIsMax( c, k ) )
  N.push_back( sGetIncr( c, k ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cells 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uProperNeighborhood( const Cell & c ) const
{
  Cells N;
  for ( DGtal::Dimension k = 0; k < dimension; ++k )
    {
      if ( ! uIsMin( c, k ) )
  N.push_back( uGetDecr( c, k ) );
      if ( ! uIsMax( c, k ) )
  N.push_back( uGetIncr( c, k ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCells 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sProperNeighborhood( const SCell & c ) const
{
  SCells N;
  for ( DGtal::Dimension k = 0; k < dimension; ++k )
    {
      if ( ! sIsMin( c, k ) )
  N.push_back( sGetDecr( c, k ) );
      if ( ! sIsMax( c, k ) )
  N.push_back( sGetIncr( c, k ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uAdjacent( const Cell & p, DGtal::Dimension k, bool up ) const
{
  return up ? uGetIncr( p, k ) : uGetDecr( p, k );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCell 
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sAdjacent( const SCell & p, DGtal::Dimension k, bool up ) const
{
  return up ? sGetIncr( p, k ) : sGetDecr( p, k );
}

// ----------------------- Incidence services --------------------------
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uIncident( const Cell & c, DGtal::Dimension k, bool up ) const
{
  ASSERT( k < dim );
  ASSERT( ( ! up ) || ( uKCoord( c, k ) < uKCoord( myUpperCell, k ) ) ); 
  ASSERT( (   up ) || ( uKCoord( myLowerCell, k ) < uKCoord( c, k ) ) ); 
  Cell d( c );
  if ( up ) ++d.myCoordinates[ k ];
  else      --d.myCoordinates[ k ];
  return d;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sIncident( const SCell & c, DGtal::Dimension k, bool up ) const
{
  ASSERT( k < dim );
  ASSERT( ( ! up ) || ( sKCoord( c, k ) < uKCoord( myUpperCell, k ) ) ); 
  ASSERT( (   up ) || ( uKCoord( myLowerCell, k ) < sKCoord( c, k ) ) ); 
  SCell d( c );
  bool sign = up ? d.myPositive : ! d.myPositive;
  for ( DGtal::Dimension i = 0; i <= k; ++i )
    if ( sIsOpen( d, i ) ) 
      sign = ! sign;
  d.myPositive = sign;
  if ( up ) ++d.myCoordinates[ k ];
  else      --d.myCoordinates[ k ];
  return d;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cells
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uLowerIncident( const Cell & c ) const
{
  Cells N;
  for ( DirIterator q = uDirs( c ); q != 0; ++q )
    {
      DGtal::Dimension k = *q;
      Integer x = uKCoord( c, k );
      if ( uKCoord( myLowerCell, k ) < x )
  N.push_back( uIncident( c, k, false ) );
      if ( x < uKCoord( myUpperCell, k ) )
  N.push_back( uIncident( c, k, true ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cells
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uUpperIncident( const Cell & c ) const
{
  Cells N;
  for ( DirIterator q = uOrthDirs( c ); q != 0; ++q )
    {
      DGtal::Dimension k = *q;
      Integer x = uKCoord( c, k );
      if ( uKCoord( myLowerCell, k ) < x )
  N.push_back( uIncident( c, k, false ) );
      if ( x < uKCoord( myUpperCell, k ) )
  N.push_back( uIncident( c, k, true ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCells
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sLowerIncident( const SCell & c ) const
{
  SCells N;
  for ( DirIterator q = sDirs( c ); q != 0; ++q )
    {
      DGtal::Dimension k = *q;
      Integer x = sKCoord( c, k );
      if ( uKCoord( myLowerCell, k ) < x )
  N.push_back( sIncident( c, k, false ) );
      if ( x < uKCoord( myUpperCell, k ) )
  N.push_back( sIncident( c, k, true ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCells
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sUpperIncident( const SCell & c ) const
{
  SCells N;
  for ( DirIterator q = sOrthDirs( c ); q != 0; ++q )
    {
      DGtal::Dimension k = *q;
      Integer x = sKCoord( c, k );
      if ( uKCoord( myLowerCell, k ) < x )
  N.push_back( sIncident( c, k, false ) );
      if ( x < uKCoord( myUpperCell, k ) )
  N.push_back( sIncident( c, k, true ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uAddFaces( Cells& faces, const Cell& c, Dimension axis ) const
{
  // std::cerr << c << std::endl;
  DGtal::Dimension dim_of_c = uDim( c );
  if ( axis >= dim_of_c ) return;
  DirIterator q = uDirs( c );
  for ( Dimension i = 0; i < axis; ++i ) ++q;
  Cell f1 = uIncident( c, *q, false );
  Cell f2 = uIncident( c, *q, true );
  faces.push_back( f1 );
  faces.push_back( f2 );
  uAddFaces( faces, f1, axis );
  uAddFaces( faces, f2, axis );
  uAddFaces( faces, c, axis+1 );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uAddCoFaces( Cells& cofaces, const Cell& c, Dimension axis ) const
{
  // std::cerr << c << std::endl;
  DGtal::Dimension dim_of_c = uDim( c );
  if ( axis >= dimension - dim_of_c ) return;
  DirIterator q = uOrthDirs( c );
  for ( Dimension i = 0; i < axis; ++i ) ++q;
  Cell f1 = uIncident( c, *q, false );
  Cell f2 = uIncident( c, *q, true );
  cofaces.push_back( f1 );
  cofaces.push_back( f2 );
  uAddCoFaces( cofaces, f1, axis );
  uAddCoFaces( cofaces, f2, axis );
  uAddCoFaces( cofaces, c, axis+1 );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cells
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uFaces( const Cell & c ) const
{
  Cells N;
  uAddFaces( N, c, 0 );
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::Cells
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
uCoFaces( const Cell & c ) const
{
  Cells N;
  uAddCoFaces( N, c, 0 );
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sDirect( const SCell & p, DGtal::Dimension k ) const
{
  ASSERT( k < dim );
  bool sign = p.myPositive;
  for ( DGtal::Dimension i = 0; i <= k; ++i )
    if ( sIsOpen( p, i ) ) 
      sign = ! sign;
  return sign;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sDirectIncident( const SCell & p, DGtal::Dimension k ) const
{
  ASSERT( k < dim );
  SCell d( p );
  bool sign = d.myPositive;
  for ( DGtal::Dimension i = 0; i <= k; ++i )
    if ( sIsOpen( d, i ) ) 
      sign = ! sign;

  bool up = sign;
  d.myPositive = POS;
  ASSERT( ( ! up ) || ( sKCoord( d, k ) < uKCoord( myUpperCell, k ) ) ); 
  ASSERT( (   up ) || ( uKCoord( myLowerCell, k ) < sKCoord( d, k ) ) ); 
  if ( up )  ++d.myCoordinates[ k ];
  else  --d.myCoordinates[ k ];
  
  return d;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
typename DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::SCell
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
sIndirectIncident( const SCell & p, DGtal::Dimension k ) const
{
  ASSERT( k < dim );
  SCell d( p );
  bool sign = d.myPositive;
  for ( DGtal::Dimension i = 0; i <= k; ++i )
    if ( sIsOpen( d, i ) ) 
      sign = ! sign;

  bool up = ! sign;
  d.myPositive = NEG;
  ASSERT( ( ! up ) || ( sKCoord( d, k ) < uKCoord( myUpperCell, k ) ) ); 
  ASSERT( (   up ) || ( uKCoord( myLowerCell, k ) < sKCoord( d, k ) ) ); 

  if ( up ) ++d.myCoordinates[ k ];
  else --d.myCoordinates[ k ];
  
  return d;
}




//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
void
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
selfDisplay ( std::ostream & out ) const
{
  out << "[CodedKhalimskySpaceND]";
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
bool
DGtal::CodedKhalimskySpaceND<dim, TInteger, TCode>::
isValid() const
{
  return true;
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //
template < DGtal::Dimension dim, typename TInteger, typename TCode >
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
                    const CodedKhalimskySpaceND<dim, TInteger, TCode> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


